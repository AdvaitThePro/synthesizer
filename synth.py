"""
Sample waveform synthesizer.
Creates some simple waveform samples with adjustable parameters.

Written by Irmen de Jong (irmen@razorvine.net) - License: MIT open-source.
"""
from rhythmbox import Sample
from math import sin, pi, floor, fabs, log
import itertools
import sys
import random

__all__ = ["key_freq", "WaveSynth", "Oscillator", "SimpleOscillator"]


def key_freq(key_number, a4=440.0):
    """
    Return the note frequency for the given piano key number.
    C4 is key 40 and A4 is key 49 (=440 hz).
    https://en.wikipedia.org/wiki/Piano_key_frequencies
    """
    return 2**((key_number-49)/12) * a4


class WaveSynth:
    """
    Waveform sample synthesizer. Can generate various wave forms based on mathematic functions:
    sine, square (perfect or with harmonics), triangle, sawtooth (perfect or with harmonics),
    variable harmonics, white noise.  It also supports an optional LFO for Frequency Modulation.
    The resulting waveform sample data is in integer 16 or 32 bits format.
    """
    def __init__(self, samplerate=Sample.norm_samplerate, samplewidth=Sample.norm_samplewidth):
        if samplewidth not in (2, 4):
            raise ValueError("only sample widths 2 and 4 are supported")
        self.samplerate = samplerate
        self.samplewidth = samplewidth
        self.oscillator = Oscillator(self.samplerate)
        self.simple_oscillator = SimpleOscillator(self.samplerate)

    def to_sample(self, sample_array, fadeout=True):
        s = Sample.from_array(sample_array, self.samplerate, 1)
        return s.fadeout(0.1 if fadeout else 0)

    def sine(self, frequency, duration, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """Simple sine wave. Optional FM using a supplied LFO."""
        wave = self.__sine(frequency, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def sine_gen(self, frequency, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """Simple sine wave generator. Optional FM using a supplied LFO."""
        wave = self.__sine(frequency, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def square(self, frequency, duration, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """
        A perfect square wave [max/-max].
        It is fast, but the square wave is not as 'natural' sounding as the ones
        generated by the square_h function (which is based on harmonics).
        """
        wave = self.__square(frequency, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def square_gen(self, frequency, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """
        Generator for a perfect square wave [max/-max].
        It is fast, but the square wave is not as 'natural' sounding as the ones
        generated by the square_h function (which is based on harmonics).
        """
        wave = self.__square(frequency, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def square_h(self, frequency, duration, num_harmonics=16, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """A square wave based on harmonic sine waves (more natural sounding than pure square)"""
        wave = self.__square_h(frequency, num_harmonics, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def square_h_gen(self, frequency, num_harmonics=16, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """Generator for a square wave based on harmonic sine waves (more natural sounding than pure square)"""
        wave = self.__square_h(frequency, num_harmonics, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def triangle(self, frequency, duration, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """Perfect triangle waveform (not using harmonics). Optional FM using a supplied LFO."""
        wave = self.__triangle(frequency, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def triangle_gen(self, frequency, amplitude=0.9999, phase=0.0, bias=0.0, fm_lfo=None):
        """Generator for a perfect triangle waveform (not using harmonics). Optional FM using a supplied LFO."""
        wave = self.__triangle(frequency, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def sawtooth(self, frequency, duration, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """Perfect sawtooth waveform (not using harmonics)."""
        wave = self.__sawtooth(frequency, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def sawtooth_gen(self, frequency, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """Generator for a perfect sawtooth waveform (not using harmonics)."""
        wave = self.__sawtooth(frequency, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def sawtooth_h(self, frequency, duration, num_harmonics=16, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """Sawtooth waveform based on harmonic sine waves"""
        wave = self.__sawtooth_h(frequency, num_harmonics, amplitude, phase, bias, fm_lfo)
        return self.__render_samples(duration, wave)

    def sawtooth_h_gen(self, frequency, num_harmonics=16, amplitude=0.75, phase=0.0, bias=0.0, fm_lfo=None):
        """Generator for a Sawtooth waveform based on harmonic sine waves"""
        wave = self.__sawtooth_h(frequency, num_harmonics, amplitude, phase, bias, fm_lfo)
        while True:
            yield int(next(wave))

    def pulse(self, frequency, duration, amplitude=0.75, phase=0.0, bias=0.0, pulsewidth=0.1, fm_lfo=None, pwm_lfo=None):
        """
        Perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwm_lfo oscillator should yield values between 0 and 1 (=the pulse width factor), or it will be clipped.
        """
        wave = self.__pulse(frequency, amplitude, phase, bias, pulsewidth, fm_lfo, pwm_lfo)
        return self.__render_samples(duration, wave)

    def pulse_gen(self, frequency, amplitude=0.75, phase=0.0, bias=0.0, pulsewidth=0.1, fm_lfo=None, pwm_lfo=None):
        """
        Generator for perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwm_lfo oscillator should yield values between 0 and 1 (=the pulse width factor), or it will be clipped.
        """
        wave = self.__pulse(frequency, amplitude, phase, bias, pulsewidth, fm_lfo, pwm_lfo)
        while True:
            yield int(next(wave))

    def harmonics(self, frequency, duration, num_harmonics, amplitude=0.9999, phase=0.0, bias=0.0, only_even=False, only_odd=False, fm_lfo=None):
        """Makes a waveform based on harmonics. This is slow because many sine waves are added together."""
        wave = self.__harmonics(frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fm_lfo)
        return self.__render_samples(duration, wave)

    def harmonics_gen(self, frequency, num_harmonics, amplitude=0.9999, phase=0.0, bias=0.0, only_even=False, only_odd=False, fm_lfo=None):
        """Generator for a waveform based on harmonics. This is slow because many sine waves are added together."""
        wave = self.__harmonics(frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fm_lfo)
        while True:
            yield int(next(wave))

    def white_noise(self, duration, amplitude=0.9999, bias=0.0):
        """White noise (randomness) waveform."""
        wave = self.__white_noise(amplitude, bias)
        return self.__render_samples(duration, wave)

    def white_noise_gen(self, amplitude=0.9999, bias=0.0):
        """Generator for White noise (randomness) waveform."""
        wave = self.__white_noise(amplitude, bias)
        while True:
            yield int(next(wave))

    def linear(self, duration, startamp, finishamp):
        """A linear constant or sloped waveform."""
        wave = self.__linear(duration, startamp, finishamp)
        return self.__render_samples(duration, wave)

    def linear_gen(self, duration, startamp, finishamp):
        """Generator for linear constant or sloped waveform (it ends when it reaches the specified duration)"""
        wave = self.__linear(duration, startamp, finishamp)
        for _ in range(int(duration*self.samplerate)):
            yield int(next(wave))

    def __sine(self, frequency, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        if fm_lfo:
            return self.oscillator.sine(frequency, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)
        else:
            return self.simple_oscillator.sine(frequency, amplitude*scale, phase, bias*scale)

    def __square(self, frequency, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        if fm_lfo:
            return self.oscillator.square(frequency, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)
        else:
            return self.simple_oscillator.square(frequency, amplitude*scale, phase, bias*scale)

    def __square_h(self, frequency, num_harmonics, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        return self.oscillator.square_h(frequency, num_harmonics, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)

    def __triangle(self, frequency, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        if fm_lfo:
            return self.oscillator.triangle(frequency, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)
        else:
            return self.simple_oscillator.triangle(frequency, amplitude*scale, phase, bias*scale)

    def __sawtooth(self, frequency, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        if fm_lfo:
            return self.oscillator.sawtooth(frequency, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)
        else:
            return self.simple_oscillator.sawtooth(frequency, amplitude*scale, phase, bias*scale)

    def __sawtooth_h(self, frequency, num_harmonics, amplitude, phase, bias, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        return self.oscillator.sawtooth_h(frequency, num_harmonics, amplitude*scale, phase, bias*scale, fm_lfo=fm_lfo)

    def __pulse(self, frequency, amplitude, phase, bias, pulsewidth, fm_lfo, pwm_lfo):
        assert 0 <= pulsewidth <= 1
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        if fm_lfo:
            return self.oscillator.pulse(frequency, amplitude*scale, phase, bias*scale, pulsewidth, fm_lfo=fm_lfo, pwm_lfo=pwm_lfo)
        else:
            return self.simple_oscillator.pulse(frequency, amplitude*scale, phase, bias*scale, pulsewidth, pwm_lfo=pwm_lfo)

    def __harmonics(self, frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fm_lfo):
        scale = self.__check_and_get_scale(frequency, amplitude, bias)
        return self.oscillator.harmonics(frequency, num_harmonics, amplitude*scale, phase, bias*scale, only_even=only_even, only_odd=only_odd, fm_lfo=fm_lfo)

    def __white_noise(self, amplitude, bias):
        scale = self.__check_and_get_scale(1, amplitude, bias)
        return self.oscillator.white_noise(amplitude*scale, bias*scale)

    def __linear(self, duration, startamp, finishamp):
        num_samples = int(duration*self.samplerate)
        increment = (finishamp-startamp)/(num_samples-1)
        return self.oscillator.linear(startamp, increment)

    def __check_and_get_scale(self, freq, amplitude, bias):
        assert freq <= self.samplerate/2    # don't exceed the Nyquist frequency
        assert 0 <= amplitude <= 1.0
        assert -1 <= bias <= 1.0
        scale = 2 ** (self.samplewidth * 8 - 1) - 1
        return scale

    def __render_samples(self, duration, wave):
        samples = Sample.get_array(self.samplewidth)
        for _ in range(int(duration*self.samplerate)):
            samples.append(int(next(wave)))
        return samples


class OscillatorBase:
    def __init__(self, samplerate=None):
        self.samplerate = samplerate or Sample.norm_samplerate


class Oscillator(OscillatorBase):
    """
    Oscillator that provides generators for several types of waveforms.
    You can also apply FM to an osc, and/or an ADSR envelope.
    These are generic oscillators and as such have floating-point inputs and result values
    with variable amplitude (though usually -1.0...1.0), depending on what parameters you use.
    Using a FM LFO is computationally quite heavy, so if you know you don't use FM,
    consider using the SimpleOscillator instead. It contains optimized algorithms for this case.
    """
    def __init__(self, samplerate=None):
        super().__init__(samplerate)

    def sine(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """Returns a generator that produces a sine wave. Optionally applies a FM LFO."""
        # The FM compensates for the phase change by means of phase_correction.
        # See http://stackoverflow.com/questions/3089832/sine-wave-glissando-from-one-pitch-to-another-in-numpy
        # and http://stackoverflow.com/questions/28185219/generating-vibrato-sine-wave
        # The same idea is applied to the other waveforms to correct their phase with FM.
        fm_lfo = fm_lfo or itertools.repeat(0.0)
        phase_correction = phase*2*pi
        freq_previous = frequency
        increment = 2*pi/self.samplerate
        t = 0
        while True:
            freq = frequency*(1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            yield sin(t*freq+phase_correction)*amplitude+bias
            t += increment

    def triangle(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """Returns a generator that produces a perfect triangle wave (not using harmonics)."""
        fm_lfo = fm_lfo or itertools.repeat(0.0)
        phase_correction = phase
        freq_previous = frequency
        increment = 1/self.samplerate
        t = 0
        while True:
            freq = frequency * (1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            tt = t*freq+phase_correction
            yield 4*amplitude*(abs((tt+0.75) % 1 - 0.5)-0.25)+bias
            t += increment

    def square(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """Returns a generator that produces a perfect square wave [max/-max] (not using harmonics)."""
        fm_lfo = fm_lfo or itertools.repeat(0.0)
        phase_correction = phase
        freq_previous = frequency
        increment = 1/self.samplerate
        t = 0
        while True:
            freq = frequency*(1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            tt = t*freq + phase_correction
            yield (-amplitude if int(tt*2) % 2 else amplitude)+bias
            t += increment

    def square_h(self, frequency, num_harmonics=16, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """
        Returns a generator that produces a square wave based on harmonic sine waves.
        It is a lot heavier to generate than square because it has to add many individual sine waves.
        It's done by adding only odd-integer harmonics, see https://en.wikipedia.org/wiki/Square_wave
        """
        return self.harmonics(frequency, num_harmonics, amplitude, phase, bias, only_odd=True, fm_lfo=fm_lfo)

    def sawtooth(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """Returns a generator that produces a perfect sawtooth waveform (not using harmonics)."""
        fm_lfo = fm_lfo or itertools.repeat(0.0)
        increment = 1/self.samplerate
        freq_previous = frequency
        phase_correction = phase
        t = 0
        while True:
            freq = frequency*(1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            tt = t*freq + phase_correction
            yield bias+amplitude*2*(tt - floor(0.5+tt))
            t += increment

    def sawtooth_h(self, frequency, num_harmonics=16, amplitude=1.0, phase=0.0, bias=0.0, fm_lfo=None):
        """
        Returns a generator that produces a sawtooth wave based on harmonic sine waves.
        It is a lot heavier to generate than square because it has to add many individual sine waves.
        It's done by adding all harmonics, see https://en.wikipedia.org/wiki/Sawtooth_wave
        """
        for y in self.harmonics(frequency, num_harmonics, amplitude, phase+0.5, bias, fm_lfo=fm_lfo):
            yield bias-y+bias

    def pulse(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, pulsewidth=0.1, fm_lfo=None, pwm_lfo=None):
        """
        Returns a generator that produces a perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwm_lfo oscillator will be clipped between 0 and 1 as pulse width factor.
        """
        assert 0 <= pulsewidth <= 1
        epsilon = sys.float_info.epsilon
        pwm_lfo = pwm_lfo or itertools.repeat(pulsewidth)
        fm_lfo = fm_lfo or itertools.repeat(0.0)
        increment = 1/self.samplerate
        freq_previous = frequency
        phase_correction = phase
        t = 0
        while True:
            pw = next(pwm_lfo)
            if pw <= 0:
                pw = epsilon
            elif pw >= 1:
                pw = 1.0-epsilon
            freq = frequency*(1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            tt = t*freq+phase_correction
            yield (amplitude if tt % 1 < pw else -amplitude)+bias
            t += increment

    def harmonics(self, frequency, num_harmonics, amplitude=1.0, phase=0.0, bias=0.0, only_even=False, only_odd=False, fm_lfo=None):
        """
        Returns a generator that produces a waveform based on harmonics.
        This is computationally intensive because many sine waves are added together.
        """
        fm_lfo = fm_lfo or itertools.repeat(0.0)  # endless zeros if no fm_lfo provided
        increment = 2*pi/self.samplerate
        phase_correction = phase*2*pi
        freq_previous = frequency
        t = 0
        # remove harmonics above the Nyquist frequency:
        num_harmonics = min(num_harmonics, int(self.samplerate/2/frequency))
        while True:
            h = 0.0
            freq = frequency*(1+next(fm_lfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            q = t*freq + phase_correction
            if only_odd:
                for k in range(1, 2*num_harmonics, 2):
                    h += sin(q*k)/k
            elif only_even:
                h += sin(q)*0.7  # always include harmonic #1 as base
                for k in range(2, 2*num_harmonics, 2):
                    h += sin(q*k)/k
            else:
                for k in range(1, 1+num_harmonics):
                    h += sin(q*k)/k/2
            yield h*amplitude + bias
            t += increment

    def white_noise(self, amplitude=1.0, bias=0.0):
        """Returns a generator that produces white noise (randomness) waveform."""
        while True:
            yield random.uniform(-amplitude, amplitude) + bias

    def linear(self, startlevel, increment=0.0):
        """Returns a generator that produces a linear sloped value."""
        if increment == 0.0:
            yield from itertools.repeat(startlevel)
        while True:
            yield startlevel
            startlevel += increment

    def envelope(self, oscillator, attack, decay, sustain, sustain_level, release, stop_at_end=False, cycle=False):
        """
        Returns the oscillator with an ADSR volume envelope applied to it.
        A,D,S,R are in seconds, sustain_level is an amplitude factor.
        """
        assert attack >= 0 and decay >= 0 and sustain >= 0 and release >= 0
        assert 0 <= sustain_level <= 1
        while True:
            time = 0.0
            end_time_decay = attack + decay
            end_time_sustain = end_time_decay + sustain
            end_time_release = end_time_sustain + release
            increment = 1/self.samplerate
            if attack:
                amp_change = 1/attack*increment
                amp = 0.0
                while time < attack:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
            if decay:
                amp = 1.0
                amp_change = (sustain_level-1)/decay*increment
                while time < end_time_decay:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
            while time < end_time_sustain:
                yield next(oscillator)*sustain_level
                time += increment
            if release:
                amp = sustain_level
                amp_change = (-sustain_level)/release*increment
                while time < end_time_release:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
                if amp > 0:
                    yield next(oscillator)*amp
            if not cycle:
                break
        if not stop_at_end:
            while True:
                yield 0.0

    def add(self, oscillator1, oscillator2):
        """Adds the wave from two oscillators together into one output wave."""
        while True:
            yield next(oscillator1)+next(oscillator2)

    def modulate_amp(self, oscillator, modulator):
        """Modulate the amplitude of the wave of an oscillator by another oscillator (the modulator."""
        while True:
            yield next(oscillator)*next(modulator)

    def delay(self, oscillator, seconds):
        """
        Delays an oscillator.
        If you use a negative value, it skips ahead in time instead.
        Note that if you want to precisely phase-shift an oscillator, you should perhaps
        use the phase parameter on the oscillator function itself instead.
        """
        if seconds < 0:
            for _ in range(int(-self.samplerate*seconds)):
                next(oscillator)
        else:
            for _ in range(int(self.samplerate*seconds)):
                yield 0.0
        yield from oscillator

    def abs(self, oscillator):
        """Returns the absolute values from an oscillator."""
        return self.custom(oscillator, fabs)

    def custom(self, oscillator, func):
        """Apply custom function to every oscillator value."""
        while True:
            yield func(next(oscillator))

    def clip(self, oscillator, minimum=None, maximum=None):
        """Clips the values from an oscillator at the given mininum and/or maximum value."""
        assert not(minimum is None and maximum is None)
        if minimum is None:
            minimum = sys.float_info.min
        if maximum is None:
            maximum = sys.float_info.max
        while True:
            yield max(min(next(oscillator), maximum), minimum)

    def tee(self, oscillator, n=2):
        """
        Return n independent oscillator clones from a single oscillator.
        This is needed when you want to use an oscillator multiple times within a single
        oscillator chain.
        """
        return itertools.tee(oscillator, n)

    def echo(self, oscillator, after, amount, delay, decay):
        """
        Mix given number of echos of the oscillator into itself.
        The decay is the factor with which each echo is decayed in volume (can be >1 to increase in volume instead).
        If you use a very short delay the echos blend into the sound and the effect is more like a reverb.
        """
        # first play the first part till the echos start
        for _ in range(int(self.samplerate*after)):
            yield next(oscillator)
        # now start mixing the echos
        amp = decay
        if decay < 1:
            # avoid computing echos that you can't hear:
            amount = int(min(amount, log(0.000001, decay)))
        echo_oscs = list(self.tee(oscillator, amount+1))
        echos = [echo_oscs[0]]
        echo_delay = delay
        for echo in echo_oscs[1:]:
            echo = self.delay(echo, echo_delay)
            echo = self.modulate_amp(echo, itertools.repeat(amp))
            echos.append(echo)
            echo_delay += delay
            amp *= decay
        while True:
            yield sum([next(echo) for echo in echos])


class SimpleOscillator(OscillatorBase):
    """
    Oscillator that provides generators for several types of waveforms.
    This one doesn't allow FM or PWM and doesn't allow its parameters to be changed
    after it was created. However, the calculations offered here are several times
    faster than their counterparts in the full blown Oscillator.
    """
    def __init__(self, samplerate=None):
        super().__init__(samplerate)

    def sine(self, frequency, amplitude=1.0, phase=0.0, bias=0.0):
        """Returns a generator that produces a sine wave."""
        rate = self.samplerate/frequency
        increment = 2*pi/rate
        t = phase*2*pi
        while True:
            yield sin(t)*amplitude+bias
            t += increment

    def triangle(self, frequency, amplitude=1.0, phase=0.0, bias=0.0):
        """Returns a generator that produces a perfect triangle wave (not using harmonics)."""
        t = phase/frequency
        increment = 1/self.samplerate
        amplitude *= 4
        while True:
            yield amplitude*(abs((t*frequency+0.75) % 1 - 0.5)-0.25)+bias
            t += increment

    def square(self, frequency, amplitude=1.0, phase=0.0, bias=0.0):
        """Returns a generator that produces a perfect square wave [max/-max] (not using harmonics)."""
        t = phase/frequency
        increment = 1/self.samplerate
        while True:
            yield (-amplitude if int(t*frequency*2) % 2 else amplitude)+bias
            t += increment

    def sawtooth(self, frequency, amplitude=1.0, phase=0.0, bias=0.0):
        """Returns a generator that produces a perfect sawtooth waveform (not using harmonics)."""
        t = phase/frequency
        increment = 1/self.samplerate
        amplitude *= 2
        while True:
            tt = t*frequency
            yield bias+amplitude*(tt - floor(0.5+tt))
            t += increment

    def pulse(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, pulsewidth=0.1, pwm_lfo=None):
        """
        Returns a generator that produces a perfect pulse waveform (not using harmonics).
        Optional Pulse-width modulation. If used, the pulsewidth argument is ignored.
        The pwm_lfo oscillator will be clipped between 0 and 1 as pulse width factor.
        """
        assert 0 <= pulsewidth <= 1
        if pwm_lfo:
            # optimized loop without FM, but with PWM
            epsilon = sys.float_info.epsilon
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                pw = next(pwm_lfo)
                if pw <= 0:
                    pw = epsilon
                elif pw >= 1:
                    pw = 1.0-epsilon
                yield (amplitude if t*frequency % 1 < pw else -amplitude)+bias
                t += increment
        else:
            # no FM, no PWM
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                yield (amplitude if t*frequency % 1 < pulsewidth else -amplitude)+bias
                t += increment
