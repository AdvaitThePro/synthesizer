"""
Sample waveform synthesizer.
Creates some simple waveform samples with adjustable parameters.

Written by Irmen de Jong (irmen@razorvine.net) - License: MIT open-source.
"""
from rhythmbox import Sample
from math import sin, pi, floor
import sys
import random
import array

__all__ = ["key_freq", "Wavesynth"]


def key_freq(key_number, a4=440.0):
    """
    Return the note frequency for the given piano key number.
    C4 is key 40 and A4 is key 49 (=440 hz).
    https://en.wikipedia.org/wiki/Piano_key_frequencies
    """
    return 2**((key_number-49)/12) * a4


class Wavesynth:
    """
    Waveform sample synthesizer. Can generate various wave forms based on mathematic functions:
    sine, square (perfect or with harmonics), triangle, sawtooth (perfect or with harmonics),
    variable harmonics, white noise.  It also supports an optional LFO for Frequency Modulation.
    """
    def __init__(self, samplerate=Sample.norm_samplerate, samplewidth=Sample.norm_sampwidth):
        if samplewidth not in (1, 2, 4):
            raise ValueError("only samplewidth sizes 1, 2 and 4 are supported")
        self.samplerate = samplerate
        self.samplewidth = samplewidth
        self.oscillator = Oscillator(self.samplerate)

    def to_sample(self, sample_array, fadeout=True):
        s = Sample.from_array(sample_array, self.samplerate, 1)
        return s.fadeout(0.1 if fadeout else 0)

    def sine(self, frequency, duration, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Simple sine wave. Optional FM using a supplied LFO."""
        wave = self.__sine(frequency, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def sine_gen(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Simple sine wave generator. Optional FM using a supplied LFO."""
        wave = self.__sine(frequency, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def square(self, frequency, duration, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """
        A perfect square wave [max/-max].
        It is fast, but the square wave is not as 'natural' sounding as the ones
        generated by the square_h function (which is based on harmonics).
        """
        wave = self.__square(frequency, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def square_gen(self, frequency, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """
        Generator for a perfect square wave [max/-max].
        It is fast, but the square wave is not as 'natural' sounding as the ones
        generated by the square_h function (which is based on harmonics).
        """
        wave = self.__square(frequency, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def square_h(self, frequency, duration, num_harmonics=12, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """A square wave based on harmonic sine waves (more natural sounding than pure square)"""
        wave = self.__square_h(frequency, num_harmonics, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def square_h_gen(self, frequency, num_harmonics=12, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Generator for a square wave based on harmonic sine waves (more natural sounding than pure square)"""
        wave = self.__square_h(frequency, num_harmonics, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def triangle(self, frequency, duration, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Perfect triangle waveform (not using harmonics). Optional FM using a supplied LFO."""
        wave = self.__triangle(frequency, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def triangle_gen(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Generator for a perfect triangle waveform (not using harmonics). Optional FM using a supplied LFO."""
        wave = self.__triangle(frequency, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def sawtooth(self, frequency, duration, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """Perfect sawtooth waveform (not using harmonics)."""
        wave = self.__sawtooth(frequency, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def sawtooth_gen(self, frequency, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """Generator for a perfect sawtooth waveform (not using harmonics)."""
        wave = self.__sawtooth(frequency, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def sawtooth_h(self, frequency, duration, num_harmonics=12, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """Sawtooth waveform based on harmonic sine waves"""
        wave = self.__sawtooth_h(frequency, num_harmonics, amplitude, phase, bias, fmlfo)
        return self.__render_samples(duration, wave)

    def sawtooth_h_gen(self, frequency, num_harmonics=12, amplitude=0.8, phase=0.0, bias=0.0, fmlfo=None):
        """Generator for a Sawtooth waveform based on harmonic sine waves"""
        wave = self.__sawtooth_h(frequency, num_harmonics, amplitude, phase, bias, fmlfo)
        while True:
            yield int(next(wave))

    def pulse(self, frequency, duration, amplitude=0.8, phase=0.0, bias=0.0, pulsewidth=0.1, fmlfo=None, pwmlfo=None):
        """
        Perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwmlfo oscillator should yield values between 0 and 1 (=the pulse width factor), or it will be clipped.
        """
        wave = self.__pulse(frequency, amplitude, phase, bias, pulsewidth, fmlfo, pwmlfo)
        return self.__render_samples(duration, wave)

    def pulse_gen(self, frequency, amplitude=0.8, phase=0.0, bias=0.0, pulsewidth=0.1, fmlfo=None, pwmlfo=None):
        """
        Generator for perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwmlfo oscillator should yield values between 0 and 1 (=the pulse width factor), or it will be clipped.
        """
        wave = self.__pulse(frequency, amplitude, phase, bias, pulsewidth, fmlfo, pwmlfo)
        while True:
            yield int(next(wave))

    def harmonics(self, frequency, duration, num_harmonics, amplitude=1.0, phase=0.0, bias=0.0, only_even=False, only_odd=False, fmlfo=None):
        """Makes a waveform based on harmonics. This is slow because many sine waves are added together."""
        wave = self.__harmonics(frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fmlfo)
        return self.__render_samples(duration, wave)

    def harmonics_gen(self, frequency, num_harmonics, amplitude=1.0, phase=0.0, bias=0.0, only_even=False, only_odd=False, fmlfo=None):
        """Generator for a waveform based on harmonics. This is slow because many sine waves are added together."""
        wave = self.__harmonics(frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fmlfo)
        while True:
            yield int(next(wave))

    def white_noise(self, duration, amplitude=1.0, bias=0.0):
        """White noise (randomness) waveform."""
        wave = self.__white_noise(amplitude, bias)
        return self.__render_samples(duration, wave)

    def white_noise_gen(self, amplitude=1.0, bias=0.0):
        """Generator for White noise (randomness) waveform."""
        wave = self.__white_noise(amplitude, bias)
        while True:
            yield int(next(wave))

    def linear(self, duration, startamp, finishamp):
        """A linear constant or sloped waveform."""
        wave = self.__linear(duration, startamp, finishamp)
        return self.__render_samples(duration, wave)

    def linear_gen(self, duration, startamp, finishamp):
        """Generator for linear constant or sloped waveform (it ends when it reaches the specified duration)"""
        wave = self.__linear(duration, startamp, finishamp)
        for _ in range(int(duration*self.samplerate)):
            yield int(next(wave))

    def __sine(self, frequency, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.sine(frequency, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __square(self, frequency, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.square(frequency, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __square_h(self, frequency, num_harmonics, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.square_h(frequency, num_harmonics, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __triangle(self, frequency, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.triangle(frequency, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __sawtooth(self, frequency, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.sawtooth(frequency, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __sawtooth_h(self, frequency, num_harmonics, amplitude, phase, bias, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.sawtooth_h(frequency, num_harmonics, amplitude*scale, phase, bias*scale, fmlfo=fmlfo)

    def __pulse(self, frequency, amplitude, phase, bias, pulsewidth, fmlfo, pwmlfo):
        assert 0 <= pulsewidth <= 1
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.pulse(frequency, amplitude*scale, phase, bias*scale, pulsewidth, fmlfo=fmlfo, pwmlfo=pwmlfo)

    def __harmonics(self, frequency, num_harmonics, amplitude, phase, bias, only_even, only_odd, fmlfo):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.harmonics(frequency, num_harmonics, amplitude*scale, phase, bias*scale, only_even=only_even, only_odd=only_odd, fmlfo=fmlfo)

    def __white_noise(self, amplitude, bias):
        scale = self.__check_and_get_scale(amplitude, bias)
        return self.oscillator.white_noise(amplitude*scale, bias*scale)

    def __linear(self, duration, startamp, finishamp):
        num_samples = int(duration*self.samplerate)
        increment = (finishamp-startamp)/(num_samples-1)
        return self.oscillator.linear(startamp, increment)

    def __check_and_get_scale(self, amplitude, bias):
        assert 0 <= amplitude <= 1.0
        assert -1 <= bias <= 1.0
        scale = 2 ** (self.samplewidth * 8 - 1) - 1
        return scale

    def __render_samples(self, duration, wave):
        if self.samplewidth == 1:
            samples = array.array('b')
        elif self.samplewidth == 2:
            samples = array.array('h')
        elif self.samplewidth == 4:
            samples = array.array('l')
        else:
            raise ValueError("only samplewidth sizes 1, 2 and 4 are supported")
        for _ in range(int(duration*self.samplerate)):
            samples.append(int(next(wave)))
        return samples


class Oscillator:
    """
    Oscillator that provides generators for several types of waveforms.
    You can also apply FM to an osc, and/or an ADSR envelope.
    """
    def __init__(self, samplerate=Sample.norm_samplerate):
        self.samplerate = samplerate

    def sine(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Returns a generator that produces a sine wave. Optionally applies a FM LFO."""
        if fmlfo:
            # The FM compensates for the phase change by means of phase_correction.
            # See http://stackoverflow.com/questions/3089832/sine-wave-glissando-from-one-pitch-to-another-in-numpy
            # and http://stackoverflow.com/questions/28185219/generating-vibrato-sine-wave
            phase_correction = phase*2*pi
            freq_previous = frequency
            increment = 2*pi/self.samplerate
            t = 0
            while True:
                freq = frequency*(1+next(fmlfo))
                phase_correction += (freq_previous-freq)*t
                freq_previous = freq
                yield sin(t*freq+phase_correction)*amplitude+bias
                t += increment
        else:
            # optimized loop without FM
            rate = self.samplerate/frequency
            increment = 2*pi/rate
            t = phase*2*pi
            while True:
                yield sin(t)*amplitude+bias
                t += increment

    def triangle(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Returns a generator that produces a perfect triangle wave (not using harmonics)."""
        if fmlfo:
            phase_correction = phase
            freq_previous = frequency
            increment = 1/self.samplerate
            t = 0
            while True:
                freq = frequency * (1+next(fmlfo))
                phase_correction += (freq_previous-freq)*t
                freq_previous = freq
                tt = t*freq+phase_correction
                yield 4*amplitude*(abs((tt+0.75) % 1 - 0.5)-0.25)+bias
                t += increment
        else:
            # optimized loop without FM
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                yield 4*amplitude*(abs((t*frequency+0.75) % 1 - 0.5)-0.25)+bias
                t += increment

    def square(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Returns a generator that produces a perfect square wave [max/-max] (not using harmonics)."""
        if fmlfo:
            phase_correction = phase
            freq_previous = frequency
            increment = 1/self.samplerate
            t = 0
            while True:
                freq = frequency*(1+next(fmlfo))
                phase_correction += (freq_previous-freq)*t
                freq_previous = freq
                tt = t*freq + phase_correction
                yield (-amplitude if int(tt*2) % 2 else amplitude)+bias
                t += increment
        else:
            # optimized loop without FM
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                yield (-amplitude if int(t*frequency*2) % 2 else amplitude)+bias
                t += increment

    def square_h(self, frequency, num_harmonics=12, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """
        Returns a generator that produces a square wave based on harmonic sine waves.
        It is a lot heavier to generate than square because it has to add many individual sine waves.
        It's done by adding only odd-integer harmonics, see https://en.wikipedia.org/wiki/Square_wave
        """
        return self.harmonics(frequency, num_harmonics, amplitude, phase, bias, only_odd=True, fmlfo=fmlfo)

    def sawtooth(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """Returns a generator that produces a perfect sawtooth waveform (not using harmonics)."""
        if fmlfo:
            increment = 1/self.samplerate
            freq_previous = frequency
            phase_correction = phase
            t = 0
            while True:
                freq = frequency*(1+next(fmlfo))
                phase_correction += (freq_previous-freq)*t
                freq_previous = freq
                tt = t*freq + phase_correction
                yield bias+amplitude*2*(tt - floor(0.5+tt))
                t += increment
        else:
            # optimized loop without FM
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                tt = t*frequency
                yield bias+amplitude*2*(tt - floor(0.5+tt))
                t += increment

    def sawtooth_h(self, frequency, num_harmonics=12, amplitude=1.0, phase=0.0, bias=0.0, fmlfo=None):
        """
        Returns a generator that produces a sawtooth wave based on harmonic sine waves.
        It is a lot heavier to generate than square because it has to add many individual sine waves.
        It's done by adding all harmonics, see https://en.wikipedia.org/wiki/Sawtooth_wave
        """
        for y in self.harmonics(frequency, num_harmonics, amplitude, phase+0.5, bias, fmlfo=fmlfo):
            yield bias-y+bias

    def pulse(self, frequency, amplitude=1.0, phase=0.0, bias=0.0, pulsewidth=0.1, fmlfo=None, pwmlfo=None):
        """
        Returns a generator that produces a perfect pulse waveform (not using harmonics).
        Optional FM and/or Pulse-width modulation. If you use PWM, pulsewidth is ignored.
        The pwmlfo oscillator should yield values between 0 and 1 (=the pulse width factor), or it will be clipped.
        """
        assert 0 <= pulsewidth <= 1
        epsilon = sys.float_info.epsilon
        if not pwmlfo:
            pwmlfo = (i+pulsewidth for i in iter(int, 1))    # endless generator returning pulsewidth values
        if fmlfo:
            increment = 1/self.samplerate
            freq_previous = frequency
            phase_correction = phase
            t = 0
            while True:
                pw = next(pwmlfo)
                if pw <= 0:
                    pw = epsilon
                elif pw >= 1:
                    pw = 1.0-epsilon
                freq = frequency*(1+next(fmlfo))
                phase_correction += (freq_previous-freq)*t
                freq_previous = freq
                tt = t*freq+phase_correction
                yield (amplitude if tt % 1 < pw else -amplitude)+bias
                t += increment
        else:
            # optimized loop without FM
            t = phase/frequency
            increment = 1/self.samplerate
            while True:
                pw = next(pwmlfo)
                if pw <= 0:
                    pw = epsilon
                elif pw >= 1:
                    pw = 1.0-epsilon
                yield (amplitude if t*frequency % 1 < pw else -amplitude)+bias
                t += increment

    def harmonics(self, frequency, num_harmonics, amplitude=1.0, phase=0.0, bias=0.0, only_even=False, only_odd=False, fmlfo=None):
        """
        Returns a generator that produces a waveform based on harmonics.
        This is computationally intensive because many sine waves are added together.
        """
        fmlfo = fmlfo or iter(int, 1)   # endless zeros if no fmlfo provided
        increment = 2*pi/self.samplerate
        phase_correction = phase*2*pi
        freq_previous = frequency
        t = 0
        while True:
            h = 0.0
            freq = frequency*(1+next(fmlfo))
            phase_correction += (freq_previous-freq)*t
            freq_previous = freq
            q = t*freq + phase_correction
            if only_odd:
                for k in range(1, 2*num_harmonics, 2):
                    h += sin(q*k)/k
            elif only_even:
                h += sin(q)*0.7  # always include harmonic #1 as base
                for k in range(2, 2*num_harmonics, 2):
                    h += sin(q*k)/k
            else:
                for k in range(1, 1+num_harmonics):
                    h += sin(q*k)/k/2
            yield h*amplitude + bias
            t += increment

    def white_noise(self, amplitude=1.0, bias=0.0):
        """Returns a generator that produces white noise (randomness) waveform."""
        while True:
            yield random.uniform(-amplitude, amplitude) + bias

    def linear(self, startlevel, increment=0.0):
        """Returns a generator that produces a linear sloped value."""
        while True:
            yield startlevel
            startlevel += increment

    def envelope(self, oscillator, attack, decay, sustain, sustain_level, release, stop_at_end=False, cycle=False):
        """
        Returns the oscillator with an ADSR volume envelope applied to it.
        A,D,S,R are in seconds, sustain_level is an amplitude factor.
        """
        assert attack >= 0 and decay >= 0 and sustain >= 0 and release >= 0
        assert 0 <= sustain_level <= 1
        while True:
            time = 0.0
            end_time_decay = attack + decay
            end_time_sustain = end_time_decay + sustain
            end_time_release = end_time_sustain + release
            increment = 1/self.samplerate
            if attack:
                amp_change = 1/attack*increment
                amp = 0.0
                while time < attack:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
            if decay:
                amp = 1.0
                amp_change = (sustain_level-1)/decay*increment
                while time < end_time_decay:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
            while time < end_time_sustain:
                yield next(oscillator)*sustain_level
                time += increment
            if release:
                amp = sustain_level
                amp_change = (-sustain_level)/release*increment
                while time < end_time_release:
                    yield next(oscillator)*amp
                    amp += amp_change
                    time += increment
                if amp > 0:
                    yield next(oscillator)*amp
            if not cycle:
                break
        if not stop_at_end:
            while True:
                yield 0.0

    def add(self, oscillator1, oscillator2):
        """Adds the wave from two oscillators together into one output wave."""
        while True:
            yield next(oscillator1)+next(oscillator2)

    def modulate_amp(self, oscillator, modulator):
        """Modulate the amplitude of the wave of an oscillator by another oscillator (the modulator."""
        while True:
            yield next(oscillator)*next(modulator)
